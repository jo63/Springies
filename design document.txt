Design Document: 
Kevin Oh and Ryan Fishel

Design goals: In this project we tried to find a way to reduce the amount of redundant code by trying to implement an inheritance hierarchy to aspects of the code we thought could benefit from the hierarchy, even if it didn't necessarily need it. 
As a result, there were several tradeoffs in the code. These will be discussed later. 

In order to create a new sprite or new physics force, one just needs to add an additional line that adheres to the syntax outlined on the Cps 308 site. 
If the user wishes to create a new type of sprite, one needs to create the appropriate subclass of Sprite in the simulation package and make sure the SpriteCommand class has the appropriate subclass implemented for the new sprite that can create that sprite and pass it to the model via the sprite factory. 
If the user wishes to create a new type of physics force, it is much the same process as creating a sprite, except it would be a subclass of Force in the physicsForces package and the necessary subclass in the physicsCommand. 

Pros: 
The use of the factory superclass and its respective subclasses, physicsFactory and spriteFactory removed a lot of redundant code compared to the initial method of having two near identical copies of factory to load the physicsForces and sprites. 
The use of the command pattern for the two types of factories removed the nested if-else trees within the code which made the code look smoother. 
The use of the Force superclass made the Physics class cleaner by removing the need for a separate instance variable for each different type of force. By having a map of forces, it was simpler to iterate through the map in the getEnvironmentVector method to create the resulting force vector to be applied to the masses. 
The use of 4 separate wall repulsion subclasses removed the if statements and switch cases in the Wall Repulsion class and the rather contentious wall map. 

Cons:
The biggest issue with the code currently is the use of the Force superclass. Although it does provide a level of abstraction, the subclasses really do not share much in common with one another. If anything, the viscosity and gravity forces seem very different from the center of mass or wall repulsion forces as the latter two seem to almost behave like a sprite in the sense that it has a position on the map that gets "updated" like the masses as the center of mass can change based on the relative positions of the masses on the canvas and the wall repulsion can change in the sense that the bounds can change by user input. 
Although the force superclass does make the code look cleaner in some senses (like exemplified above), it also makes the code messier. In the physics class's update method, the goal is to update the center of mass's position as well as update the bounds for the wall repulsions. In order to do this, we had to check first to see whether those two types of forces were present in the map and then typecast in order to perform subclass specific methods. This level of specificity seems to have removed much of the "closed" nature of the physics class that we were trying to aim for. There was much debate whether to move it back to the original plan of having separate variables for each of the forces or to have two different inheritance hierarchies (gravity and viscosity together and the center of mass and wall repulsion in another), but in the end, as per recommendation by our TA, we stuck with the decision to keep the Force superclass. 
Another issue that we faced was with the Wall repulsion force. Originally, we implemented the force in a very interesting way in the sense that the WallRepulsion class had a map of all the applicable walls that were passed to it from the physicsFactory class. There were some internal vector sum calculations in the class's returnForce method which iterated through the wall map to vector sum the forces. This provided several issues: 1, we needed the physics class to have an instance of WallRepulsion that really did not serve a purpose except to provide a "gate" in a sense for the physicsFactory to be able to add walls to that WallRepulsion variable's wall map. 2, there were many different uses of switch statements and if trees that really defeated the purpose of trying to remove such things using a smarter design. 2, the physicsCommand for wallrepulsion was a special case on its own because it had to get either a model or the model's physics' wallrepulsion instance passed into it. 
As a result, we opted to separate the walls into 4 separate ones, which did remove the if and switch statements but also caused another issue due to the use of the Force map in physics. As there is only one wall repulsion keyword for the environment.xsp file, we realized there were errors being caused by the map trying to hold different values of wall repulsion (TopWall, BottomWall...etc) with only one key ("wall") as a result, we had to write some very specific code in the physics factory to deal with the issue, which again made the code look rather problematic. 